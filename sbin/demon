#!/usr/bin/env bash
shopt -s extglob
shopt -s nullglob
#set -x
:
Destroy() {
    :
}
trap Destroy SIGINT SIGQUIT
:
X() {
    EXIT="${1:-0}"
    exit "${EXIT}"
}
Msg() {
    [[ "${#1}" -gt 0 ]] && printf '%s\n\n' "${1}" && return

    if [[ $EXIT -eq 0 ]]
    then
        printf '%s\n' "That went suprisingly well."
    elif [[ $EXIT -eq 1  ]]
    then
        printf '%s\n' "Error"
    elif [[ $EXIT -eq 100 ]]
    then
        :
    elif [[ $EXIT -eq 101 ]]
    then
        printf '%s\n' "Please run this script with sudo."
    elif [[ $EXIT -eq 102 ]]
    then
        printf '%s\n' "Cleanup is complete."
    elif [[ $EXIT -eq 103 ]]
    then
        printf '%s\n' "Logger closed."
    elif [[ $EXIT -eq 104 ]]
    then
        printf '%s\n' "Dnsmasq stopped."
    elif [[ $EXIT -eq 105 ]]
    then
        printf '%s\n' "httpd stopped."
    elif [[ $EXIT -eq 106 ]]
    then
        printf '%s\n' "Logging facility does not exist."
    fi
}
trap Msg EXIT
#################
:
# permission check
gate() {
    [[ $UID != 0 ]] && X 101
}
:
:
get_cwd() {
    SOURCE="${BASH_SOURCE[-1]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    _CWD="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    :
}
get_cwd

check() {
    [[ "${#_CWD}" -eq 0 ]] && printf "The CWD must be defined.\\n"
    local file; file="${1}"
    [[ ${#1} -eq 0 ]] && return 2
    # pathchk could come in handy
    [[ -r $_CWD/$file ]] && return 0
    return 1
}
:
source "${_CWD}/lib/env"
# before starting, make sure dnsmasq already running

MASQ()
{
    # local LOG
    # LOG=/tmp/dnsmasq.log
    #"${LOG:-$DNSMASQ_LOG}"
    [[ ! -x $DNSMASQ ]] && Msg "Dnsmasq not found" && X 1
    :
    if [[ ! -r $DNSMASQ_PID ]]
    then
        (
            "${DNSMASQ}" \
                --log-queries \
                --stop-dns-rebind \
                --user="${HTTPD_USER}" \
                --listen-address=127.0.0.1 \
                --address=/local/127.0.0.1 \
                --log-facility=- \
                --pid-file="${DNSMASQ_PID}" \
                --no-resolv \
                --no-hosts \
                --cache-size=0 \
                --conf-file="${DNSMASQ_CONFIG}" 2>&1 | nc -k -l 9001
        ) &
        disown %1
        printf '%s\n' $'Starting `dnsmasq`.'
    else
        read -r pid < "${DNSMASQ_PID}"
        Msg "Dnsmasq seems to be running. ($pid)"
        X 100
    fi
}

HTTPD()
{
    [[ ! -x $HTTPD ]] && Msg "Apache httpd server not found" && X 1
    :
    if [[ ! -r $HTTPD_PID ]]
    then
        (
            "${APACHECTL}" \
                -f "${HTTPD_CONFIG}" \
                -k start
        ) &
        printf '%s\n' $'Starting `httpd`. '
        wait
    else
        read -r pid < "${HTTPD_PID}"
        Msg "httpd seems to be running. ($pid)"
        X 100
    fi
}


Listen()
{
    case $1 in
        -D|--dns)
            # if ! nc -z localhost 9001 >/dev/null 2>&1
            # then
            #     printf '%s\n' "Service not available."
            #     X 100
            # fi
            nc localhost 9001
            X 103
            ;;
        -H|--access|--httpd)
            # check if port is accessible
            if ! nc -z localhost 80 >/dev/null 2>&1
            then
                printf '%s\n' "Cannot connect to port 80."
                X 1
            fi

            # check if httpd is using that port
            if ! lsof -i tcp:80 | grep httpd >/dev/null 2>&1
            then
                printf '%s' "Waiting for httpd ... "
            fi

            # if it is not using it, wait for it
            (
                while ! lsof -i tcp:80 | grep httpd >/dev/null 2>&1
                do
                    waited='yes'
                    sleep 0.5
                done
                [[ $waited == 'yes' ]] && printf '%s\n\n' "ready."
            ) &
            wait

            nc localhost 9006
            X 103
            ;;
        *)
            Msg "Accepted flags are -D and -H."
            X 1
            ;;
    esac
}

# Start
Start()
{
    MASQ &
    wait
    HTTPD
}

#
# Stop
#
Stop()
{
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        "${APACHECTL}" -f "${HTTPD_CONFIG}" -k stop > /dev/null 2>&1 & wait
        if [[ -r $HTTPD_PID  ]]; then
            rm "${HTTPD_PID}" >/dev/null 2>&1
            Msg "httpd proccesses stopped."
        else
            Msg "No httpd process found."
        fi
    fi

    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        pkill -9 -F "${DNSMASQ_PID}" dnsmasq >/dev/null 2>&1 & wait
        if [[ -r "${DNSMASQ_PID}" ]]; then
            rm "${DNSMASQ_PID}" >/dev/null 2>&1
            Msg "dnsmasq proccess stopped."
        else
            Msg "No dnsmasq process found."
        fi
    fi

    Destroy
}

Restart()
{
	  "${APACHECTL}" -f "${HTTPD_CONFIG}" -k restart > /dev/null 2>&1
}

Test()
{
    printf '%s\n' "${exe[@]}"

    printf '%s\n' "${HTTPD_ROOT}"

    "${DNSMASQ}" -C "${DNSMASQ_CONFIG}" --test &
    wait
    "${APACHECTL}" -f "${HTTPD_CONFIG}" -t
    #-D DUMP_VHOSTS #| column -t

    X 0
}

Status() {
    local args

    [[ -r "${DNSMASQ_PID}" ]] && read -r tmp1 < "${DNSMASQ_PID}"
    mapfile -t tmp2 < <(pgrep httpd)

    proc=($tmp1 ${tmp2[*]})
    printf -v args '%s' "${proc[@]/#/ \-pid }"
    \top -u -s 2 -stats command,pid,pgrp,ppid,uid $args
}

Run()
{
    case $1 in
        start  )
            gate;
            shift
            case $1 in
                -D|--dnsmasq)
                    MASQ
                    X 0
                    ;;
                -H|--httpd)
                    HTTPD
                    X 0
                    ;;
            esac
            Start
            ;;
        stop   )
            gate
            shift
            Stop "${@}"
            ;;
        restart)
            gate
            Restart
            ;;
        test   )
            gate
            Test
            ;;
        listen|watch)
            shift
            Listen "${@}"
            ;;
        clean  )
            Destroy
            ;;
        status)
            Status
            ;;
        *      )
            echo "Unknown option: try 'Start', 'Stop', 'Restart' or 'Test'"
            X 1
            ;;
    esac
}

Run "${@}"
