#!/usr/bin/env bash
shopt -s extglob
shopt -s nullglob
#set -x
:
Destroy () {
    if [[ $STATE == "LISTEN" ]]
    then
        exec 3>&-
        exec 4>&-
        exec 5>&-
        exec 6>&-
        exec 7>&-
        X 103
    fi

    gate

    if [[ -r $HTTPD_PID ]]; then
        read -r pid < "${HTTPD_PID}"
        kill "${pid}" &
        wait
        rm "${HTTPD_PID}"
    fi

    if [[ -r $DNSMASQ_PID ]]; then
        read -r pid < "${DNSMASQ_PID}"
        kill "${pid}" &
        wait
        rm "${DNSMASQ_PID}"
    fi

    for item in  "${HTTPD_CUSTOM_LOG}" \
                     "${HTTPD_ERROR_LOG}" \
                     "${HTTPD_VHOST_CUSTOM_LOG}" \
                     "${HTTPD_VHOST_ERROR_LOG}" \
                     "${DNSMASQ_LOG}"
    do
        rm "${item}" >/dev/null 2>&1
    done
    :
    X 102
}
trap Destroy SIGINT SIGQUIT
:
X() {
    EXIT="${1:-0}"
    exit "${EXIT}"
}
Msg () {
    [[ "${#1}" -gt 0 ]] && printf '%s\n\n' "${1}" && return

    if [[ $EXIT -eq 0 ]]
    then
        printf '%s\n' "That went suprisingly well."
    elif [[ $EXIT -eq 1  ]]
    then
        printf '%s\n' "Error"
    elif [[ $EXIT -eq 100 ]]
    then
        :
    elif [[ $EXIT -eq 101 ]]
    then
        printf '%s\n' "Please run this script with sudo."
    elif [[ $EXIT -eq 102 ]]
    then
        printf '%s\n' "Cleanup is complete."
    elif [[ $EXIT -eq 103 ]]
    then
        printf '%s\n' "Logger closed."
    fi
}
trap Msg EXIT
########################
# Executables
HTTPD="/opt/local/sbin/httpd"
DNSMASQ="/opt/local/sbin/dnsmasq"
APACHECTL="/opt/local/sbin/apachectl"
eval exe=("${HTTPD} ${APACHECTL} ${DNSMASQ}")
export HTTP_SERVER_ROOT="/opt/local"
#################
export HTTPD_USER
HTTPD_USER=$(logname)
:
# permission check
gate() {
    [[ $UID != 0 ]] && X 101
}
:
:
get_cwd() {
    SOURCE="${BASH_SOURCE[-1]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    _CWD="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    :
}
get_cwd

check() {
    [[ "${#_CWD}" -eq 0 ]] && printf "The CWD must be defined.\\n"
    local file; file="${1}"
    [[ ${#1} -eq 0 ]] && return 2
    # pathchk could come in handy
    [[ -r $_CWD/$file ]] && return 0
    return 1
}
:
source "${_CWD}/lib/env"
source "${_CWD}/lib/logger"
# before starting, make sure dnsmasq already running

MASQ()
{
    [[ ! -x $DNSMASQ ]] && Msg "Dnsmasq not found" && X 1
    :
    if [[ ! -r $DNSMASQ_PID ]]
    then
        "${DNSMASQ}" --user="${HTTPD_USER}" \
                     --log-queries \
                     --log-facility="${DNSMASQ_LOG}" \
                     --conf-file="${DNSMASQ_CONFIG}"  \
                     --pid-file="${DNSMASQ_PID}" \
                     --resolv-file="${DNS_RESOLV}" \
                     >/dev/null 2>&1 &
        printf '%s' "Hang on ... "
        wait
        printf '%s\n' "done."
    else
        read -r pid < "${DNSMASQ_PID}"
        Msg "Dnsmasq seems to be running. ($pid)"
        X 100
    fi
}

HTTPD()
{
    [[ ! -x $HTTPD ]] && Msg "Apache httpd server not found" && X 1
    :
    if [[ ! -r $HTTPD_PID ]]
    then
        :
        "${HTTPD}" -k start -f "${HTTPD_CONFIG}" &
        printf '%s' "Hang on ... "
        wait
        printf '%s\n' "done."
    else
        read -r pid < "${HTTPD_PID}"
        Msg "httpd seems to be running. ($pid)"
        X 100
    fi
}


Listen()
{
    STATE="LISTEN"
    case $1 in
        dns)
            cat "${DNSMASQ_LOG}"
            ;;
        access|httpd)
            cat "${HTTPD_CUSTOM_LOG}"
            ;;
        *)
            Msg "Unknown log."
            X 1
            ;;
    esac
    #    wait
    #cat "${HTTPD_ERROR_LOG}"

    #cat "${HTTPD_ERROR_LOG}" &
    # Open pipe for writing.

    # Write to pipe
    #ping oddworld.com >&3
    #wait
}

# Start
Start()
{
    MASQ &
    HTTPD &
}

#
# Stop
#
Stop()
{
    "${APACHECTL}" -f "${HTTPD_CONFIG}" -k stop > /dev/null 2>&1
	  if [[ -r $HTTPD_PID  ]]; then
        "${APACHECTL}" -f "${HTTPD_CONFIG}" -k stop > /dev/null 2>&1
    else
        echo "No active httpd process found."
    fi

    if [[ -r "${DNSMASQ_PID}" ]]; then
        pkill dnsmasq
    else
        echo "No active dnsmasq process found."
    fi
    Destroy
}

Restart()
{
	  "${APACHECTL}" -f "${HTTPD_CONFIG}" -k restart > /dev/null 2>&1
}

Test()
{
    printf '%s\n' "${exe[@]}"

    printf '%s\n' "${HTTPD_ROOT}"

    "${DNSMASQ}" -C "${DNSMASQ_CONFIG}" --test &
    wait
    "${APACHECTL}" -f "${HTTPD_CONFIG}" -t
    #-D DUMP_VHOSTS #| column -t

    printf '%s\n' "Now listening ..."  >&3

    X 0
}

# Watch ()
# {
#     cat  "${HTTPD_ERROR_LOG}" &
#     wait
# }

# #
# # Run
# #
Run()
{
    case $1 in
        start  )
            gate;
            shift
            case $1 in
                -D|--dnsmasq)
                    MASQ
                    X 0
                    ;;
                -H|--httpd)
                    HTTPD
                    X 0
                    ;;
            esac
            Start
            ;;
        stop   )
            gate
            shift
            Stop "${@}"
            ;;
        restart)
            gate
            Restart
            ;;
        -t|--test   )
            gate
            Test
            ;;
        --listen|--watch)
            shift
            Listen "${@}"
            ;;
        --listen )
            Listen
            ;;
        clean  )
            gate
            Destroy
            ;;
        *      ) echo "Unknown option: try 'Start', 'Stop', 'Restart' or 'Test'";;
    esac
}

### some prep stuff
# /bin/launchctl \
    #     unload -w \
    #     /System/Library/LaunchDaemons/org.apache.httpd.plist &> /dev/null



# Initiate logging.
Logger
#
Run "${@}"

# watch 'pgrep dnsmasq | wc -l ; pgrep httpd | wc -l'
