#!/usr/bin/env bash
#set -x
# (
#     # example
#     exec 7<> ./shit
#     ping oddworld.com >&7

# ) &
# wait
# exit
destroy () {
    if [[ -r $HTTPD_PID ]]; then
        read -r pid < "${HTTPD_PID}"
        kill "${pid}" &
        wait
        rm "${HTTPD_PID}"
    fi

    if [[ -r $DNSMASQ_PID ]]; then
        read -r pid < "${DNSMASQ_PID}"
        kill "${pid}" &
        wait
        rm "${DNSMASQ_PID}"
    fi
    exec 3>&-
    Clean &
    wait
}
trap destroy SIGINT SIGQUIT
:
dust () {
    if [[ $EXIT -eq 0 ]]
    then
        printf '%s\n' "That went suprisingly well."
    elif [[ $EXIT -eq 101 ]]
    then
        printf '%s\n' "Please run this script with sudo:"
    fi
}
trap dust EXIT
########################
# Executables
HTTPD="/opt/local/sbin/httpd"
DNSMASQ="/opt/local/sbin/dnsmasq"
APACHECTL="/opt/local/sbin/apachectl"
export HTTP_SERVER_ROOT="/opt/local"
#################
export HTTPD_USER
HTTPD_USER=$(logname)
:
# permission check
gate() {
    [[ $UID != 0 ]] && EXIT=101 && exit "${EXIT}"
}
:

:
:
check () {
    local file; file="${1}"
    :
    SOURCE="${BASH_SOURCE[-1]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
        DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
        SOURCE="$(readlink "$SOURCE")"
        [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    _CWD="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    :
    [[ ${#1} -eq 0 ]] && return 2
    # pathchk could come in handy
    [[ -r $_CWD/$file ]] && return 0
    return 1
}
check ''
:
:

# pass through variables
export HTTPD_ROOT; HTTPD_ROOT=$(dirname "${_CWD}")
export HTTPD_DOCUMENT_ROOT="${HTTPD_ROOT}/www"
export PHP_ROOT="${HTTPD_ROOT}/etc/php72/"
export DNSMASQ_PID="${HTTPD_ROOT}/var/run/dnsmasq.pid"
export HTTPD_PID="${HTTPD_ROOT}/var/run/httpd.pid"
:

logger ()
{
    export HTTPD_CUSTOM_LOG="${HTTPD_ROOT}/logs/access.fifo"
    [[ ! -p $HTTPD_CUSTOM_LOG ]] && \
        mkfifo "${HTTPD_CUSTOM_LOG}"
    exec 3<> "${HTTPD_CUSTOM_LOG}"; printf '%s\n' "Now logging ..."  >&3
    :
    export HTTPD_ERROR_LOG="${HTTPD_ROOT}/logs/error.fifo"
    [[ ! -p $HTTPD_ERROR_LOG ]] && \
        mkfifo "${HTTPD_ERROR_LOG}"
    #sudo -u "${HTTPD_USER}" mkfifo "${HTTPD_ERROR_LOG}"
    exec 4<> "${HTTPD_ERROR_LOG}"
    :
    export HTTPD_VHOST_CUSTOM_LOG="${HTTPD_ROOT}/logs/projects/vhosts_access.fifo"
    [[ ! -p $HTTPD_VHOST_CUSTOM_LOG ]] &&
        sudo -u "${HTTPD_USER}" mkfifo "${HTTPD_VHOST_CUSTOM_LOG}"
    exec 5<> "${HTTPD_VHOST_CUSTOM_LOG}"
    :
    export HTTPD_VHOST_ERROR_LOG="${HTTPD_ROOT}/logs/projects/vhosts_errors.fifo"
    [[ ! -p $HTTPD_VHOST_ERROR_LOG ]] &&
        sudo -u "${HTTPD_USER}" mkfifo "${HTTPD_VHOST_ERROR_LOG}"
    exec 6<> "${HTTPD_VHOST_ERROR_LOG}"

    DNSMASQ_LOG="${HTTPD_ROOT}/logs/dnsmasq.fifo"
    [[ ! -p $DNSMASQ_LOG ]] &&
        sudo -u "${HTTPD_USER}" mkfifo "${DNSMASQ_LOG}"
    exec 7<> "${DNSMASQ_LOG}"
}


export HTTPD_SERVER_NAME="prometheus"

# Configs
HTTPD_CONFIG="${HTTPD_ROOT}/conf/httpd.conf"
DNSMASQ_CONFIG="${HTTPD_ROOT}/etc/dnsmasq.conf"

# unncessary
#PHP_CONFIG="${PHP_ROOT}/php-dev.ini"
:

# before starting, make sure dnsmasq already running

MASQ ()
{
    if [[ ! -r $DNSMASQ_PID ]]
    then
        # daemon mode
        #"${DNSMASQ}" --log-queries -C "${DNSMASQ_CONFIG}" -x "${DNSMASQ_PID}"
        # non-daemon-mode
        "${DNSMASQ}" --log-queries --log-facility=- -C "${DNSMASQ_CONFIG}" --no-daemon  \
                     > "${DNSMASQ_LOG}" 1>&2
    fi
}

HTTPD ()
{
    [[ -x $HTTPD ]] && "${HTTPD}" -k start -f "${HTTPD_CONFIG}"
    exec 3>"${HTTPD_CUSTOM_LOG}"
    exec 3>"${HTTPD_ERROR_LOG}"
}


Listen()
{
    cat "${HTTPD_CUSTOM_LOG}"
    cat "${HTTPD_ERROR_LOG}"

    #cat "${HTTPD_ERROR_LOG}" &
    # Open pipe for writing.

    # Write to pipe
    #ping oddworld.com >&3
    #wait
}

# Start
Start()
{
    exit 10
    Listen
    MASQ
    HTTPD
    # > /dev/null 2>&1
}

#
# Stop
#
Stop()
{
	  if [[ -r $HTTPD_PID ]]; then
        "${APACHECTL}" -f "${HTTPD_CONFIG}" -k stop > /dev/null 2>&1
    else
        echo "No active httpd process found."
    fi

    if [ -r "${DNSMASQ_PID}" ]; then
        pkill dnsmasq
    else
        echo "No active dnsmasq process found."
    fi
    destroy
}

Restart()
{
	  "${APACHECTL}" -f "${HTTPD_CONFIG}" -k restart > /dev/null 2>&1
}

Test()
{
    printf 'executables:\n%s\n%s\n%s\n\n' "${HTTPD}" "${APACHECTL}" "${DNSMASQ}"

    printf '%s\n' "${HTTPD_ROOT}"

    "${DNSMASQ}" -C "${DNSMASQ_CONFIG}" --test &
    wait
    "${APACHECTL}" -f "${HTTPD_CONFIG}" -t
    #-D DUMP_VHOSTS #| column -t

    printf '%s\n' "Now logging ..."  >&3
    EXIT=0
    exit "${EXIT}"
}

# Watch ()
# {
#     cat  "${HTTPD_ERROR_LOG}" &
#     wait
# }

Clean ()
{
    rm "${HTTPD_CUSTOM_LOG}" \
       "${HTTPD_ERROR_LOG}" \
       "${HTTPD_VHOST_CUSTOM_LOG}" \
       "${HTTPD_VHOST_ERROR_LOG}"
}
# #
# # Run
# #
Run()
{
    case $1 in
        start  )
            gate;
            shift
            case $1 in
                --masq)
                    MASQ
                    exit
                    ;;
                --httpd)
                    HTTPD
                    exit
                    ;;
            esac
            Start
            ;;
        stop   )
            gate
            Stop
            ;;
        restart)
            gate
            Restart
            ;;
        -t|--test   )
            gate
            Test
            ;;
        --watch  )
            Watch
            ;;
        --listen )
            Listen
            ;;
        clean  ) Clean
                 ;;
        *      ) echo "Unknown option: try 'Start', 'Stop', 'Restart' or 'Test'";;
    esac
}

### some prep stuff
# /bin/launchctl \
    #     unload -w \
    #     /System/Library/LaunchDaemons/org.apache.httpd.plist &> /dev/null




#
# Run a phase based on the selector
#DNS
Run "${@}"

# watch 'pgrep dnsmasq | wc -l ; pgrep httpd | wc -l'
