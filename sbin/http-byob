#!/usr/bin/env bash
shopt -s extglob
shopt -s nullglob
unset CDPATH
#set -x
:
Clean() {
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        rm "${HTTPD_PID}" >/dev/null 2>&1
    fi

    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        rm "${DNSMASQ_PID}" >/dev/null 2>&1
    fi
    # ipconfig set en1 DHCP &
    #     wait
    printf '%s\n' "Done cleaning."
}


Destroy() {
    tput clear
}
trap Destroy SIGINT SIGQUIT
:
X() {
    EXIT="${1:-0}"
    exit "${EXIT}"
}

Msg() {
    [[ "${#1}" -gt 0 ]] && printf '%s\n\n' "${1}" && return

    if [[ $EXIT -eq 0 ]]
    then
        printf '\n\n%s\n' "That went suprisingly well."
    elif [[ $EXIT -eq 1  ]]
    then
        printf '%s\n' "Error"
    elif [[ $EXIT -eq 100 ]]
    then
        :
    elif [[ $EXIT -eq 101 ]]
    then
        printf '%s\n' "Please run this script with sudo."
    elif [[ $EXIT -eq 102 ]]
    then
        printf '%s\n' "Cleanup is complete."
    elif [[ $EXIT -eq 103 ]]
    then
        printf '%s\n' "Logger closed."
    elif [[ $EXIT -eq 104 ]]
    then
        printf '%s\n' "Dnsmasq stopped."
    elif [[ $EXIT -eq 105 ]]
    then
        printf '%s\n' "httpd stopped."
    elif [[ $EXIT -eq 106 ]]
    then
        printf '%s\n' "Logging facility does not exist."
    fi
}
trap Msg EXIT
#################
:
# permission check
gate() {
    [[ $UID -eq 0 ]] || exec sudo "$0" "$@"
}
:
check() {
    if [[ $1 == '-D' && -r "${DNSMASQ_PID}" ]]
    then
        echo "PID file found."
        if ! ps -p "${DNSMASQ_PID}" >/dev/null 2>&1
        then
            echo "Process by PID not running."
            return 1
        fi
        return 0
    elif [[ $1 == '-H' && -r "${HTTPD_PID}" ]]
    then
        echo "PID file found."

        if ps -p "${HTTPD_PID}" >/dev/null 2>&1
        then
            echo "Process by PID not running."v
            return 0
        fi
        return 0
    fi
    return 1
}
:
MASQ()
{
    local pid
    local resolvFile; resolvFile="/etc/resolver/lan"

    [[ ! -d "/etc/resolver/" ]] && mkdir "/etc/resolver/"


    if [[ ! -f "${resolvFile}" ]]
    then
        touch "${resolvFile}"
	      printf '%s\n' "nameserver 127.0.0.1" >| "${resolvFile}"
    else
        printf '%s\n' "nameserver 127.0.0.1" >| "${resolvFile}"
    fi


    [[ ! -x $DNSMASQ ]] && Msg "Dnsmasq not found" && X 1
    :
    if ! check -D
    then
        while IFS= read -r line; do
            printf '%s\n' "$line" | nc "${HOSTNAME}" "${DNSMASQ_LOG_PORT}"
        done < <(
            "${DNSMASQ}" \
                --log-queries \
                --log-facility=- \
                --log-async=15 \
                --stop-dns-rebind \
                --bind-interfaces \
                --user="${HTTPD_USER}" \
                --port="${DNS_PORT}" \
                --local-service \
		            --server=/lan/127.0.0.1 \
                --listen-address=127.0.0.1 \
                --address=/lan/127.0.0.1 \
                --pid-file="${DNSMASQ_PID}" \
                --cache-size=0 \
                --no-resolv \
                --no-hosts \
                --strict-order \
                --conf-file="${DNSMASQ_CONFIG}" 2>&1
        ) &
        disown %1
        printf '%s\n' $'Starting `dnsmasq`.'
    else
        pid=$(< "${DNSMASQ_PID}")
        Msg "Dnsmasq seems to be running. ($pid)"
        X 100
    fi
}

HTTPD()
{
    local pid
    [[ ! -x $HTTPD ]] && Msg "Apache httpd server not found" && X 1
    :
    check -H
    echo $?;exit
    if [[ $? -ne 0 ]]
    then
        while IFS= read -r line; do
            printf '%s\n' "$line" | nc "${HOSTNAME}" "${HTTPD_LOG_PORT}"
        done < <(
            "${APACHECTL}" \
                -f "${HTTPD_CONFIG}" \
                -e info \
                -DFOREGROUND \
                -k start 2>&1
        ) &
        disown %1
        printf '%s\n' $'Starting `httpd`. '
    else
        pid=$(< "${HTTPD_PID}")
        Msg "httpd seems to be running. ($pid)"
        X 100
    fi
}


Listen()
{
    case $1 in
        -D|--dns)
            # check if dnsmasq is using that port
            if ! lsof -i tcp:"${DNS_PORT}" | grep dnsmasq >/dev/null 2>&1
            then
                printf '%s' "Waiting for dnsmasq ... "
            fi

            # if it is not using it, wait for it
            (
                while ! lsof -i :"${DNS_PORT}" | grep dnsmasq >/dev/null 2>&1
                do
                    waited='yes'
                    sleep 0.5
                done
                [[ $waited == 'yes' ]] && printf '%s\n\n' "ready."
            ) &
            wait

            Msg 'Logging ... '
            nc -k -l "${DNSMASQ_LOG_PORT}"
            X 103
            ;;
        -H|--access|--httpd)
            # check if port is accessible
            if ! nc -z "${HOSTNAME}" 80 >/dev/null 2>&1
            then
                printf '%s\n' "Cannot connect to port 80."
                X 1
            fi

            # check if httpd is using that port
            if ! lsof -i :80 | grep httpd >/dev/null 2>&1
            then
                printf '%s' "Waiting for httpd ... "
            fi

            # if it is not using it, wait for it
            (
                while ! lsof -i :80 | grep httpd >/dev/null 2>&1
                do
                    waited='yes'
                    sleep 0.5
                done
                [[ $waited == 'yes' ]] && printf '%s\n\n' "ready."
            ) &
            wait

            Msg 'Logging ... '
            nc -k -l "${HTTPD_LOG_PORT}"
            X 103
            ;;
        *)
            Msg "Accepted flags are -D and -H."
            X 1
            ;;
    esac
}

# Start
Start()
{
    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        MASQ
    fi
    :
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        HTTPD
    fi
}

#
# Stop
Stop()
{
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        pkill -TERM -F "${HTTPD_PID}" >/dev/null 2>&1 &
        printf '%s' "Stopping Apache httpd ... "
        wait
        printf '%s (%s)\n' "done." "$?"

        if check -H
        then
            rm "${HTTPD_PID}" >/dev/null 2>&1
            Msg "httpd proccesses stopped."
        else
            Msg "No httpd process found."
        fi
    fi

    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        pkill -9 -F "${DNSMASQ_PID}" dnsmasq >/dev/null 2>&1 & wait
        if check -D
        then
            rm "${DNSMASQ_PID}" >/dev/null 2>&1
            Msg "dnsmasq process stopped."
        else
            Msg "No dnsmasq process found."
        fi
    fi
    killall nc >/dev/null 2>&1
}

Restart()
{
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        if ! check -H
        then
            Msg "No httpd process found." && return 1
        fi
        pkill -HUP -F "${HTTPD_PID}" &
        printf '%s' "Restarting Apache httpd ... "
        wait
        if ps -p "${HTTPD_PID}" >/dev/null 2>&1
        then
            printf '%s (%s)\n' "done." "$?"
        else
            printf '%s (%s)\n' "failed." "$?"
            Clean -H
            X 101
        fi
    fi

    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        [[ ! -r "${DNSMASQ_PID}" ]] && Msg "No dnsmasq process found." && return
        Stop -D &
        wait
        Start -D
    fi

}

Test()
{
    local name
    if ! source './sbin/lib/env' >/dev/null 2>&1
    then
        printf "Unable to source environment variables!\\n"
        X 1
    fi
    for exe in ${exe[@]}; do
        name="$(basename "${exe}")"
        if [[ -x "${exe}" ]]; then
            printf '%-20s found!' "${name}"
            if [[ "${name}" == 'dnsmasq' ]]; then
                printf '\t'
                "${DNSMASQ}" -C "${DNSMASQ_CONFIG}" --test &
                wait
            elif [[  "${name}" == 'apachectl' ]]; then
                printf '\t'
                "${APACHECTL}" -f "${HTTPD_CONFIG}" -t &
                wait
                printf '\t'
                "${APACHECTL}" -f "${HTTPD_CONFIG}" -S &
                wait
            fi
        else
            printf '%-20s not found!\n' "${name}"
        fi
    done
}


Status() {
    local pid
    tput sgr0 # turn off text attributes
    tput clear # clear stuff away
    ps -o "ppid,pid,etime,user,comm" | head -n 1 | column -t

    while IFS= read -r line; do
        tput sc

        [[ -r "${DNSMASQ_PID}" ]] && tmp1=$(< "${DNSMASQ_PID}")
        mapfile -t tmp2 < <(pgrep httpd)
        proc=("${tmp1}" "${tmp2[*]}")

        for pid in ${proc[@]}; do
            command ps -p "${pid}" -o "ppid=,pid=,etime=,user=,comm=" | column -t 2>&1
            tput el
        done
        sleep 2
        tput ed
        tput rc
    done < <(
        yes
    ) &
    wait
}



http-byob()
{
    case $1 in
        start  )
            gate;
            shift
            case $1 in
                -D|--dnsmasq)
                    Start -D
                    X 0
                    ;;
                -H|--httpd)
                    Start -H
                    X 0
                    ;;
            esac
            Start
            ;;
        stop   )
            gate stop
            shift
            Stop "${@}"
            ;;
        restart)
            gate
            shift
            Restart "${@}"
            ;;
        test   )
            gate test
            Test
            ;;
        listen|watch)
            shift
            Listen "${@}"
            ;;
        clean  )
            Destroy
            ;;
        status)
            Status
            ;;
        alien)
            check -H
            echo $?
            X 0
            ;;
        *)
            echo "Unknown option: try 'Start', 'Stop', 'Restart' or 'Test'"
            X 1
            ;;
    esac
}

if [[ ${BASH_SOURCE[0]} != "${0}" ]]; then
    unset -f http-byob
    if [[ "${*}" =~ '--activate' ]]; then
        bash --rcfile <(read -r httpbyob_shell < \
                             <(printf '%s' "export PS1=\"( BYOB ) ${PS1}\" ;\
                                          alias sudo='sudo ';\
                                          unset PROMPT_COMMAND;\
                                          alias status=\"sbin/http-byob status\";\
                                          alias start=\"sbin/http-byob start \";\
                                          alias stop=\"sbin/http-byob stop \";\
                                          alias restart=\"sbin/http-byob restart \";\
                                          alias test=\"sbin/http-byob test \";\
                                          alias listen=\"sbin/http-byob listen \";\
                                          set +o history;\
                                          "); printf '%s'  "${httpbyob_shell}") -i
        return
    fi
    printf '%s\n' "\`http-byob\` is not meant to be sourced!"
elif [[ "${BASH_SOURCE[0]}" == 'sbin/http-byob' ]]
then
    if ! source './sbin/lib/env' >/dev/null 2>&1
    then
        printf "Unable to source environment variables!\\n"
        X 1
    fi
    http-byob "${@}"
else
    printf '%s\n' "\`http-byob\` must be invoked from the container root -- \"sbin/http-byob\". Also, avoid using aliases!"
    X 1
fi
