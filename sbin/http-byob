#!/usr/bin/env bash
shopt -s extglob
shopt -s nullglob
unset CDPATH
#set -x
:
Clean() {
    [[ $2 == 'help' ]] && helpful <<helpmenu
Clean stuff.
helpmenu
    shift

    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        if rm "${HTTPD_PID}" >/dev/null 2>&1
        then
            printf '%s\n' "Removed httpd PID file."
        fi
    fi
    #
    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        if rm "${DNSMASQ_PID}" >/dev/null 2>&1
        then
            printf '%s\n' "Removed dnsmasq PID file."
        fi
    fi
    #
    killall nc >/dev/null 2>&1

    # ipconfig set en1 DHCP &
    #     wait
    printf '%s\n' "Done cleaning."
}
:
_D(){
    echo "SHIT"
    dnsmasq \
        --log-queries \
        --log-facility=- \
        --log-async=15 \
        --stop-dns-rebind \
        --bind-interfaces \
        --user="${HTTPD_USER}" \
        --port=53 \
        --local-service \
		    --server=/lan/127.0.0.1 \
        --address=/lan/127.0.0.1 \
        --pid-file="${DNSMASQ_PID}" \
        --cache-size=0 \
        --no-resolv \
        --no-hosts \
        --strict-order \
        --conf-file="${DNSMASQ_CONFIG}" 2>&1
}

title ()
{
    echo -ne "\\033]0;$*\\007"
}

End() {
    :
    title http-byob
    echo ""
}
trap End EXIT
:
Destroy() {
    tput rmcup
    killall nc
    :
    title http-byob
}
trap Destroy SIGINT SIGQUIT
:
Msg() {
    printf '%s\n\n' "${1:-... exiting.}"
    [[ "${#2}" -gt 0 ]] && exit "${2}"
    return 0
}
#################
:
# permission check
gate() {
    [[ $UID -eq 0 ]] || exec sudo sbin/http-byob "${@}"
}

:
check() {
    isValid "${1}"
    :
    local pid
    :
    local Q; Q="${1#\-}"
    local pid_file_ref; pid_file_ref="$Q[pid]"


    if [[ ! -r "${!pid_file_ref}" ]]
    then
        printf '%s\n' "PID file not found!"
        return 1
    else
        pid=$(<"${!pid_file_ref}")
        if ! ps -p "${pid}" >/dev/null 2>&1
        then
            printf 'The PID file indicates %s; however, no such process exists.\n' "\`${pid}\`"
            return 1
        else
            printf 'The PID file exists and corresponds to a valid process (%s)\n' "${pid}"
            title existing process
            return 0
        fi
    fi
    return 1
}
:
isValid()
{
    [[ ! "${*}" =~ ^(-D|-H|^$)$ ]] && Msg "Accepted flags are -D and -H." 1
    return 0
}
title()
{
    echo -ne "\033]0;"$*"\007"
}
:
MASQ()
{
    #    echoipdns lan
    #   return
    # maybe use a virtual file resolver?

    # Note: dnsmasq is configured NOT to read config file
    local pid

    local resolvFile; resolvFile="/etc/resolver/lan"

    [[ ! -d "/etc/resolver/" ]] && mkdir "/etc/resolver/"

    [[ ! -f "${resolvFile}" ]] && touch "${resolvFile}"
	  printf '%s\n' "nameserver 127.0.0.1" >| "${resolvFile}"


    [[ ! -x $DNSMASQ ]] && Msg "Dnsmasq not found" 1
    :

    if ! check -D >/dev/null 2>&1
    then
        title launching dnsmasq
        _D
        # while IFS= read -r line; do
        #     printf '%s\n' "$line" | nc "${HOSTNAME}" "${DNSMASQ_LOG_PORT}"
        # done < <(
        #     _D
        # )
        # #&
        # #disown %1
        printf '%s\n' $'Starting `dnsmasq`.'
    else
        check -D
        exit 100
    fi
    title exiting
}
#
HTTPD()
{
    local pid
    [[ ! -x $HTTPD ]] && Msg 'Apache httpd server not found!' 1
    :
    if ! check -H >/dev/null 2>&1
    then
        while IFS= read -r line; do
            printf '%s\n' "$line" | nc "${HOSTNAME}" "${HTTPD_LOG_PORT}"
        done < <(
            "${APACHECTL}" \
                -f "${HTTPD_CONFIG}" \
                -e info \
                -DFOREGROUND \
                -k start 2>&1
        ) &
        disown %1

        printf '%s\n' $'Starting `httpd`. '
    else
        check -H
        exit 100
    fi
}


Listen()
{
    [[ $2 == 'help' ]] && helpful <<'helpmenu'
Stream netcat logs.

EXAMPLE:
 $ sbin/http-byob listen -H  # Stream `httpd` logs

helpmenu
    shift

    title listening

    tput smcup

    [[ ! "${*}" =~ ^(-D|-H)$ ]] && Msg "Accepted flags are -D and -H." 1
    case $1 in
        -D|--dns)
            nc -k -l 9005
            wait
            # check if dnsmasq is using that port
            #    if ! lsof -n -iTCP:"${DNS_PORT}" | grep dnsmasq >/dev/null 2>&1
            #             then
            #                 printf '%s' "Waiting for dnsmasq ... "
            #             fi

            # if it is not using it, wait for it
            (
                while ! lsof -n -iTCP:"${DNS_PORT}" | grep dnsmasq >/dev/null 2>&1
                do
                    waited='yes'
                    sleep 0.5
                done
                [[ $waited == 'yes' ]] && printf '%s\n\n' "ready."
            ) &
            wait

            Msg 'Logging ... '
            nc -k -l "${DNSMASQ_LOG_PORT}"
            Msg "logger closed." 103
            ;;
        -H|--access|--httpd)
            # check if port is accessible
            if ! nc -z "${HOSTNAME}" 80 >/dev/null 2>&1
            then
                Msg "Cannot connect to port 80." 1
            fi

            # check if httpd is using that port
            if ! lsof -n -iTCP:80 | grep httpd >/dev/null 2>&1
            then
                printf '%s' "Waiting for httpd ... "
            fi

            # if it is not using it, wait for it
            (
                while ! lsof -n -iTCP:80 | grep httpd >/dev/null 2>&1
                do
                    waited='yes'
                    sleep 0.5
                done
                [[ $waited == 'yes' ]] && printf '%s\n\n' "ready."
            ) &
            wait

            Msg 'Logging ... '
            nc -k -l "${HTTPD_LOG_PORT}"
            Msg "Logger closed." 103
            ;;
    esac

    tput rmcup

}

# Start
Start()
{
    [[ $2 == 'help' ]] && helpful <<helpmenu
Start processes.

EXAMPLE:
 $ sbin/http-byob start     # launch \`dnsmasq\` and \`httpd\`
 $ sbin/http-body start -H  # launch \`httpd\`
helpmenu

    gate "${@}"; shift



    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        MASQ "${@}"
    fi
    :
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        HTTPD "${@}"
    fi
}

#
# Stop
Stop()
{
    local stopReply
    local state
    :
    [[ $2 == 'help' ]] && helpful <<'helpmenu'
Stop processes.

EXAMPLE:
 $ sbin/http-byob stop -D  # Stop `dnsmasq`
 $ sbin/http-byob stop -H  # Stop `httpd`
helpmenu
    gate "${@}"; shift
    isValid "${1}"

    if [[ "${#1}" -eq 0 ]]; then
        for i in D H
        do
            x="$i[pid]"
            y="$i[proc]"
            [[ ! -r "${!x}" ]] && continue
            z=$(<"${!x}")
            pkill -TERM -F "${!x}" >/dev/null 2>&1 &
            printf 'Stopping %s (%s) ... ' "${!y}" "${z}"
            wait
            printf 'done.\n'
        done
        printf "complete\\n"
        return
    fi


    [[ "${#1}" -gt 0 ]] && \
        local Q; Q="${1#\-}" && \
        local pid_file_ref; pid_file_ref="$Q[pid]" && \
        local proc_ref; proc_ref="$Q[proc]"

    if [[ -f "${!pid_file_ref}" ]]; then
        local pid="$(<"${!pid_file_ref}")"
    else
        printf $'Found no reference to %s\n' "${!proc_ref}"
        return
    fi

    IFS=: read -r stopReply state < <(check "${1}")

    if [[ "$state" -eq 0 ]]
    then
        pkill -TERM -F "${!pid_file_ref}" >/dev/null 2>&1 &
        printf 'Stopping %s (%s) ... ' "${!proc_ref}" "${pid}"
        wait
        printf 'done.\n'
    else
        printf $'Attempt to stop `%s` failed: %s\n' "${!proc_ref}" "${stopReply}"
    fi
    :
}

Restart()
{
    [[ $2 == 'help' ]] && helpful <<helpmenu
Restart processes.
helpmenu

    gate "${@}"; shift


    isValid "${1}"
    :
    if [[ $1 == '-H' || "${#1}" -eq 0 ]]
    then
        if ! check -H
        then
            Msg "No httpd process found." && return 1
        fi
        pkill -HUP -F "${HTTPD_PID}" &
        printf '%s' "Restarting Apache httpd ... "
        wait
        if ps -p "${HTTPD_PID}" >/dev/null 2>&1
        then
            printf '%s (%s)\n' "done." "$?"
        else
            # test if restart was successful
            printf '%s (%s)\n' "failed." "$?"
            Clean -H
            Msg "Please run this script with sudo" 101
        fi
    fi

    if [[ $1 == '-D' || "${#1}" -eq 0 ]]
    then
        [[ ! -r "${DNSMASQ_PID}" ]] && \
            Msg "No dnsmasq process found." && \
            return
        Stop -D &
        wait
        Start -D
    fi

}

Test()
{
    [[ $2 == 'help' ]] && helpful <<helpmenu
Test that configuration files are syntactically correct.
helpmenu

    gate "${@}"; shift

    local ERR
    local var

    title Testing ...

    #  if lsof -n -iTCP:"${HTTPD_PORT}" | awk '{print $1,$3}' | column -t
    #     then
    #         printf 'Port %s is occupied.\n' "${HTTPD_PORT}"
    #     fi
    #     printf '\v\v'


    if ! source './sbin/lib/env' >/dev/null 2>&1
    then
        Msg "Unable to source environment variables!" 1
    fi

    [[ -z $HTTPD ]] && Msg 'httpd not found!' 1

    [[ -z $APACHECTL ]] && Msg 'apachectl not found!' 1
    :
    # alias list
    printf '%s\n' "Server alias list:"
    while IFS='' read -r line; do
        if [[ $line =~ alias*(.+) ]]; then
            printf '%s\n' "${BASH_REMATCH[1]}"
        fi
    done < <("${APACHECTL}" -f "${HTTPD_CONFIG}" -S)

    printf '\v\v'


    [[ -z $DNSMASQ ]] && Msg 'dnsmasq not found!' 1
    [[ ! -x $DNSMASQ ]] && Msg "Dnsmasq not found" 1
    "${DNSMASQ}" -C "${DNSMASQ_CONFIG}" --test &
    wait
    printf '\v\v'

    exit
    printf 'Now testing variables ... \n\n'
    for var in DNS_PORT HTTPD_PORT DNSMASQ_LOG_PORT HTTPD_LOG_PORT;
    do
        if [[ ${!var} -eq 0 ]];then
            ERR='ERR'
        else
            ERR=''
        fi
        printf '%-30s%s\n' "${var}:${!var}" "${ERR:+ERR!}"
    done
    #         printf 'DNS_PORT
    #     [[ $HTTPD_PORT -eq 0 ]] && Msg "HTTPD_PORT not properly defined! $HTTPD_PORT"

}


Status() {
    [[ $2 == 'help' ]] && helpful <<helpmenu
Dislay the status of various processes.
helpmenu
    shift
    title status


    local pid

    tput smcup

    tput sgr0 # turn off text attributes
    ps -o "ppid,pid,etime,user,comm" | head -n 1 | column -t

    while IFS= read -r line; do
        tput sc

        [[ -r "${DNSMASQ_PID}" ]] && tmp1=$(< "${DNSMASQ_PID}")
        mapfile -t tmp2 < <(pgrep httpd)
        proc=("${tmp1}" "${tmp2[*]}")

        for pid in ${proc[@]}; do
            command ps -p "${pid}" -o "ppid=,pid=,etime=,user=,comm=" | column -t 2>&1
            tput el
        done
        sleep 2
        tput ed
        tput rc
    done < <(
        yes
    ) &
    wait

    tput rmcup
}


helpful()
{
    read -r -d '' helpStatement

    printf 'HELP:\n %s\n' "${helpStatement}"
    exit 0
}



entry(){
    if [[ ${BASH_SOURCE[0]} != "${0}" ]]; then
        unset -f http-byob
        if [[ "${*}" =~ '--activate' ]]; then
            bash --rcfile <(read -r httpbyob_shell < \
                                 <(printf '%s' "export PS1=\"( BYOB ) ${PS1}\" ;\
                                          alias sudo='sudo ';\
                                          unset PROMPT_COMMAND;\
                                          alias status=\"sbin/http-byob status\";\
                                          alias start=\"sbin/http-byob start \";\
                                          alias stop=\"sbin/http-byob stop \";\
                                          alias restart=\"sbin/http-byob restart \";\
                                          alias test=\"sbin/http-byob test \";\
                                          alias listen=\"sbin/http-byob listen \";\
                                          set +o history;\
                                          "); printf '%s'  "${httpbyob_shell}") -i
            return
        fi
        printf '%s\n' "\`http-byob\` is not meant to be sourced!"
    elif [[ "${BASH_SOURCE[0]#\.\/}" == 'sbin/http-byob' ]]
    then
        if ! source './sbin/lib/env' >/dev/null 2>&1
        then
            Msg "Unable to source environment variables!" 1
        fi
        [[ ! "${1}" == 'Test' ]] && http-byob "${@}"
    else
        printf '%s\n' "\`http-byob\` must be invoked from the container root -- \"sbin/http-byob\". Also, avoid using aliases!"
        exit 1
    fi
}

http-byob()
{
    case $1 in
        start)
            Start "${@}"
            ;;
        stop)
            Stop "${@}"
            ;;
        restart)
            Restart "${@}"
            ;;
        test)
            Test "${@}"
            ;;
        listen|watch)
            Listen "${@}"
            ;;
        clean)
            Stop "${@}"
            Clean "${@}"
            ;;
        status)
            Status "${@}"
            ;;
        check)
            shift
            check "${1}"
            ;;
        help)
            shift
            [[ "${#1}" -eq 0 ]] && exit
            eval sbin/http-byob "${1}" help
            ;;
        alien)
            compgen -A function ;exit
            check -H
            echo $?
            exit
            ;;
        __)
            __
            ;;
        *)
            Msg "Unknown option: try 'start', 'stop', 'restart', 'test', 'listen', 'clean', 'help'" 1
            ;;
    esac
}


# DEFAULTS
DNS_PORT="${DNS_PORT:=53}"
HTTPD_USER="${HTTPD_USER:=$USER}"

entry "${@}"
